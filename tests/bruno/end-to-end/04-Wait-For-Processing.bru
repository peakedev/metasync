meta {
  name: Wait For Processing
  type: http
  seq: 4
}

get {
  url: {{baseUrl}}/jobs/{{e2eJobId}}
  body: none
  auth: none
}

headers {
  Content-Type: application/json
  client_id: {{clientId}}
  client_api_key: {{clientApiKey}}
}

script:pre-request {
  // Use a proper async delay instead of busy-wait to avoid connection issues
  const waitTime = 10000; // 10 seconds
  
  console.log(`Waiting ${waitTime / 1000} seconds before checking job status...`);
  
  // Create a promise-based delay that doesn't block the event loop
  await new Promise(resolve => setTimeout(resolve, waitTime));
  
  console.log(`Wait complete, checking job status...`);
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response is an object", function() {
    expect(res.getBody()).to.be.an('object');
  });
  
  test("Check job status", function() {
    const job = res.getBody();
    const status = job.status;
    
    bru.setVar("e2eLastStatus", status);
    
    if (status === 'PENDING' || status === 'PROCESSING') {
      // Job is still processing after wait time
      // This indicates the worker may not be processing jobs correctly
      const errorMsg = `Job is still ${status} after waiting 30 seconds. This may indicate:\n` +
        `1. Worker is not running or crashed - check worker status\n` +
        `2. Worker cannot find this job - check clientReference filters match\n` +
        `3. Worker is processing but taking longer than expected\n` +
        `4. An error occurred during processing - check worker logs\n` +
        `\nTo debug:\n` +
        `- Check if worker is running: GET /workers/{workerId}\n` +
        `- Check worker logs for errors\n` +
        `- Verify job filters match worker filters (model, operation, clientReference)`;
      
      bru.setVar("e2ePollAgain", "true");
      throw new Error(errorMsg);
    } else {
      // Job is complete
      bru.setVar("e2eFinalJobStatus", status);
      bru.setVar("e2ePollAgain", "false");
      console.log(`âœ… Job completed with status: ${status}`);
    }
  });
  
  test("Job status is PROCESSED or ERROR_PROCESSING when complete", function() {
    const job = res.getBody();
    const status = job.status;
    const pollAgain = bru.getVar("e2ePollAgain");
    
    // If we're still polling, the previous test would have thrown an error
    // So if we reach here, the job should be complete
    if (pollAgain === "true") {
      // This shouldn't happen, but if it does, it means the previous test didn't throw
      throw new Error("Job is still processing but reached final assertion. This indicates a test logic error.");
    }
    
    // Job should be complete at this point
    expect(['PROCESSED', 'ERROR_PROCESSING']).to.include(status);
    bru.setVar("e2eFinalJobStatus", status);
  });
}
